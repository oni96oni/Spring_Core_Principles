빈 스코프
    빈 스코프란?
        스코프는 빈이 존재할 수 있는 범위를 뜻한다.

        싱글톤 스코프 : 기본 스코프, 스프링 컨테이너의 시작과 종료까지 유지되는 가장 넓은 범위의 스코프
        프로토타입 스코프 : 스프링 컨테이너는 프로토타입의 빈의 생성과 의존관계 주입까지만 관여! 더 관리 안한다. 그냥 만들어서 던지고 끝!
            그래서 종료메서드 호출이 안된다! PostContruct 호출해준다는데 그게 종료메서드 호출아니야??? 아니다 PostContruct는 생성전에 해주는거야

        웹관련 스코프
            request
            session
            application

    프로토타입 스코프
        프로토타입 스코프를 스프링 컨테이너에 조회하면 싱글톤 스코프와 다르게 항상 새로운 인스턴스를 생성해서 반환한다.
        핵심은 스프링 컨테이너는 프로토타입 빈을 생성, 의존관계 주입, 초기화까지만 하고 관리를 하지 않는다.
        이제부터 관리는 빈을 받은 클라이언트에게 있다, @PreDestroy같은 종료메서드가 호출되지 않는다.

        AnnotationConfigApplicationContext(PrototypeBean.class); 의 매개변수로 들어오면 @Component의 스캔 대상이 되어서 스캔된다.
        PrototypeBean에 @Component가 안붙어도 된다.

        종료메서드에 대한 호출도 클라이언트가 직접해주어야 한다.

    프로토타입 스코프 - 싱글톤 빈과 함꼐 사용시 문제점
        프로토타입 스코프의 빈 요청 -> 항상 새로운 객체 인스턴스 생성해서 반환
        요청자들 끼리 필드 변수를 공유하지 않으므로 안전하다.

        싱글톤빈이 프로토타입 빈을 사용하게된다. 싱글톤 빈은 생성 시점에만 의존관계 주입을 받기 떄문에, 프로토타입 빈이 새로 생성되기는
        하지만, 싱글톤 빈과 함께 계속 유지되는 것이 문제다.

        프로토타입 빈을 사용 의도와 달라서 문제가 발생, 프로토타입 빈을 주입시점에만 새로 생성하는 것이 아니라
        사용할때마다!

    프로토타입 스코프 - 싱글톤 빈과 함께 사용시 Provider로 문제 해결
        문제는 싱글톤 빈과 프로토타입 빈을 함꼐 사용할 떄, 어떻게 하면 사용할 때 마다 항상 새로운 프로토타입 빈을 생성할 수 있을까이다.

        1. 가장 간단한 방법은 싱글톤 빈이 프로토타입을 사용할 때 마다 스프링 컨테이너에 새로 요청하는 것이다.

        의존관계를 찾는것을 DL이라고 한다. 그런데 이렇게 스프링의 ac 전체를 주입받으면 컨테이너에 종속적인 코드가 되고, 테스트도 힘들다
        딱 DL정도의 기능만 제공하는게 필요하다

        2. ObjectFactory, ObjectProvider
        getObject()를 호출하면 그때서야 ac한테 직접찾는게 아니라 스프링 컨테이너에서 프로토타입빈을 찾아서 우리에게 반환해준다.
        둘의 차이는 ObjectFactory가 좀더 옛날것, ObjectProvider가 상속받아서 기능 몇개 더 있는것

        핵심은 무엇인가?
        DL을 간단하게 도와주는것, 스프링컨테이너에 내가 직접 조회하는것은 x, 간접적으로 찾아서 사용하는것

        3. JSR-330 Provider
        자바 표준을 사용하는 방법.
        라이브러리추가 2번째 방법과 비슷 메서드는 더 짧다 get()

        실무에서는 싱글톤 빈으로 대부분의 문제 해결!! 프로토타입빈을 직접적으로 사용하는 일은 매우 드물다.

        1순위로는 ObjectProvider 사용, 스프링이 아닌 다른컨테이너에서도 사용할수 있어야 한다면 JSR-330사용

        JPA와 스프링의 차이가 여기서 조금 있다.
        스프링과 자바 표준이 제공하는 기능이 겹친다면 대부분 스프링사용

    웹 스코프
        싱글톤은 컨테이너의 시작과 끝!
        프로토타입은 생성, 의존관계 주입, 초기화까지만!

        웹 스코프는 웹 환경에서만 동작하는 스코프
        스프링이 해당 스코프의 종료 시점까지 관리한다. 따라서 종료 메서드가 호출된다.

        웹 스코프의 종류
            REQUEST     요청이 하나가 들어오고 나갈때 까지 유지되는 스코프
            SESSION
            APPLICATION
            WEBSOCKET

    request 스코프 예제 만들기
        동시에 여러 http요청이 오면 정확히 어떤 요청이 남긴 로그인지 구분하기 어렵다.
        이럴때 사용하는것이 request 스코프이다.

        UUID를 통해 HTTP요청 구분
        UUID라는것을 만들어서 로그앞에 붙여주는것 그러면 같은 request인지 다른 request인지 구분할 수 있다.

        [UUID][requestURL]{message}

        request를 스코프로 지정하면 HTTP요청 당 하나씩 생성되고 HTTP요청이 끝나는 시점에 소멸된다. -> 끝나는 시점은 클라이언트에게 응답하는 시점

        스프링 컨테이너가 뜨는데 의존관계 주입을 받는다. 컨트롤러 올려줘야하니까.
        로그를 줘야하는데 request스코프여서 request가 없어! 고객요청이 와야하는데 고객 요청이 안왔잖아!
        이런경우 provider를 사용하면 된다!

        공통처리할때는 컨트롤러보다는 스프링 인터셉터나 서블릿 필터에서 활용하는것이 좋다.

        웹과 관련된 부분은 컨트롤러까지만 사용해야한다. 서비스 계층은 웹기술에 종속되지 않아야 유지보수 관점에서 좋다.

    스코프와 Provider
        컨트롤러 요청이 와서 scope를 사용할 수 있는 상황이어서 이제는 꺼낼 수 있다?
        말이 어렵다 그냥 요청이 올때까지 기다리게 할 수 있으니까 기다리는동안 서버돌리는것같은데

        같은 request면 다른 url에서 요청이어도 같은 스프링빈이 반환되어서 구분하기가 쉬워진다!

        그런데...
        provider같은거 안쓰고 할 수 있는 방법이 없을까?

    스코프와 프록시

