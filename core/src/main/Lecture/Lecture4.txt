스프링 컨테이너와 빈
    스프링 컨테이너 생성
        ApplicationContext를 스프링 컨테이너라고한다. 또한 인터페이스이다.
        xml, 애노테이션 기반으로도 만들 수 있다. 요즘은 애노테이션기반이 지배적
        AppConfig또한 애노테이션 기반의 자바 설정 클래스로 스프링 컨테이너를 만든것
        컨테이너란것은 그 안에 객체들을 담고있는것, BeanFactory와 ApplicationContext로 구분

        스프링 컨테이너 안에는 '스프링 빈 저장소' 존재
        구성정보를 지정해주어야 한다! 우리가 AppConfig.class 넣었듯이

        @Bean 붙어있는것 전부 호출 메서드의 (보통, 임의로 부여가능)이름을 빈 이름으로, return값의 객체를 빈 객체에 넣어준다.

        빈의 이름은 항상 달라야 한다. 오류가 발생가능

        동적인 인스턴스 관계를 스프링 빈에서 다 연결을 해준다.
        단순히 자바코드를 호출하는 것과 무슨차이???

        의존관계 자동주입이란???

        연결은 2단계로 나뉘어져 있다.

    컨테이너에 등록된 모든 빈 조회
        등록된 빈들 잘 등록되었나 어떻게 확인??
        Junit5부터는 클래스에 public 안붙여도 된다.

        iter -> 강화for문 자동생성
        컨트롤 + 알트 + v -> 타입과 참조변수 자동 생성

        getBeanDefinition() 은 빈의 정보, 메타데이터 정보

    스프링 빈 조회 - 기본
        getBean(빈이름, 타입)이라는 메서드를 사용하면 된다!
        빈이름을 생략하고 타입만 적어도 가능
        반복되는 클래스는 알트 + 엔터 이후 on demand맡겨버리면 생략가능하다.

        구체적으로 적는것은 안좋다. 역할에 의존해야하니까! 구체적으로 적으면 구현체에 의존하게된다.
        물론 무조건 그럴 수는 없다 이상적인 이야기

        테스트는 항상 실패테스트 만들기

        구체 타입으로 조회하면 유연성이 떨어진다.

    스프링 빈 조회 - 동일한 타입이 둘 이상
        타입이 2개이상이면 오류!
        빈이름을 지정하면 해결
        ac.getBeanOfType()을 사용하면 해당 타입의 모든 빈 검색가능
        클래스 안에서 static을 지정했다는 것은 여기 안에서만 사용하겠다는 뜻이다.

        컨트롤 + 쉬프트 + 엔터 -> 맨뒤로 가서 엔터칠 필요없이 바로 코드치러갈 수 있다.

        한번에 조회하는 방법조회해보는 이유 -> @Autowired와 연관이 있다.
        어떤연관???

    스프링 빈 조회 - 상속 관계★
